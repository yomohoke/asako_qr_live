<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Asahi Ad Award - Live AR</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    
    <style>
      /* 映画のようなオープニングUI */
      body { margin: 0; overflow: hidden; background: #000; }
      #overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: black; z-index: 9999; display: flex; flex-direction: column;
        align-items: center; justify-content: center; transition: opacity 1s ease;
      }
      #start-btn {
        padding: 15px 40px; border: 1px solid rgba(255,255,255,0.5);
        background: transparent; color: white; font-family: sans-serif;
        font-size: 1.2rem; letter-spacing: 0.3em; cursor: pointer;
        transition: all 0.3s; text-transform: uppercase;
      }
      #start-btn:active { background: white; color: black; transform: scale(0.95); }
      .instruction { margin-top: 20px; color: #888; font-size: 0.8rem; font-family: sans-serif; }
      
      /* スキャン中のガイド */
      #scanning-ui {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 60vw; height: 60vw; border: 2px dashed rgba(255,255,255,0.3);
        border-radius: 10px; pointer-events: none; display: none; z-index: 10;
      }
    </style>

    <script>
      // ▼ システム：オーディオ解析と状態管理
      AFRAME.registerSystem('live-controller', {
        init: function () {
          this.audio = null;
          this.analyser = null;
          this.dataArray = null;
          this.volume = 0; // 現在の音量（演出用）
          this.isPlaying = false;
        },
        
        // ユーザーがボタンを押した時に呼ばれる（iOS対策）
        setupAudio: function (audioId) {
          this.audio = document.querySelector(audioId);
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.context = new AudioContext();
          const src = this.context.createMediaElementSource(this.audio);
          this.analyser = this.context.createAnalyser();
          this.analyser.fftSize = 128; // 解析精度
          src.connect(this.analyser);
          this.analyser.connect(this.context.destination);
          this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
          
          // 一瞬だけ無音で再生してOSに許可させるハック
          this.context.resume();
        },

        // 認識した時：開演
        play: function () {
          if (this.audio && this.context) {
            this.context.resume();
            this.audio.currentTime = 0; // 最初から（あるいはループ途中からなら削除）
            this.audio.play();
            this.isPlaying = true;
          }
        },

        // 外れた時：一時停止
        pause: function () {
          if (this.audio) {
            this.audio.pause();
            this.isPlaying = false;
            this.volume = 0; // 演出も即カット
          }
        },

        tick: function () {
          if (!this.isPlaying || !this.analyser) return;
          this.analyser.getByteFrequencyData(this.dataArray);
          
          // 低音の平均を取得
          let sum = 0;
          for(let i=0; i<5; i++) sum += this.dataArray[i];
          const rawVolume = sum / 5 / 255; 
          // スムージング（急激な変化を和らげる）
          this.volume += (rawVolume - this.volume) * 0.2;
        }
      });

      // ▼ コンポーネント：ターゲット認識時の挙動（モデル出現・音楽再生）
      AFRAME.registerComponent('target-control', {
        init: function () {
          const system = this.el.sceneEl.systems['live-controller'];
          const model = this.el.querySelector('.live-model');
          const effects = this.el.querySelector('.live-effects');

          // マーカー認識時
          this.el.addEventListener('targetFound', () => {
            console.log("Live Start!");
            system.play();
            
            // モデルのアニメーション（毎回 0 -> 1 に拡大）
            // A-Frameのanimationコンポーネントをリセットして再生
            model.setAttribute('visible', true);
            model.setAttribute('scale', '0 0 0');
            setTimeout(() => {
              model.setAttribute('animation', {
                property: 'scale',
                to: '0.5 0.5 0.5', // モデルの最終サイズ
                dur: 800,
                easing: 'easeOutBack' // 勢いよく飛び出す動き
              });
            }, 50);

            effects.setAttribute('visible', true);
          });

          // マーカーロスト時
          this.el.addEventListener('targetLost', () => {
            console.log("Live Pause...");
            system.pause();
            
            // モデルを隠す（次回の出現インパクトのため）
            model.setAttribute('visible', false);
            model.removeAttribute('animation'); // アニメーションリセット
            model.setAttribute('scale', '0 0 0');
            
            effects.setAttribute('visible', false);
          });
        }
      });

      // ▼ コンポーネント：オーディオリアクティブ・メッシュ（TouchDesigner風）
      AFRAME.registerComponent('reactive-mesh', {
        init: function () {
          const geo = new THREE.SphereGeometry(1, 32, 32);
          const mat = new THREE.ShaderMaterial({
            wireframe: true, transparent: true,
            uniforms: { uTime: { value: 0 }, uVol: { value: 0 } },
            vertexShader: `
              varying vec2 vUv; uniform float uTime; uniform float uVol;
              void main() {
                vUv = uv; vec3 pos = position;
                // 音量でスパイクさせる
                float spike = sin(pos.x * 10.0 + uTime) * cos(pos.y * 10.0);
                pos += normal * spike * uVol * 0.5; 
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
              }
            `,
            fragmentShader: `
              uniform float uVol;
              void main() {
                // 音量で色が激しく明滅
                vec3 col = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.2, 0.5), uVol);
                gl_FragColor = vec4(col, 0.5 + uVol * 0.5);
              }
            `
          });
          this.mesh = new THREE.Mesh(geo, mat);
          this.el.setObject3D('mesh', this.mesh);
        },
        tick: function (t) {
          const vol = this.el.sceneEl.systems['live-controller'].volume;
          this.mesh.material.uniforms.uTime.value = t / 1000;
          this.mesh.material.uniforms.uVol.value = vol;
          // メッシュ自体を回転
          this.el.object3D.rotation.y += 0.01;
        }
      });

      // ▼ スタートボタン処理
      window.enterLive = function() {
        const overlay = document.getElementById('overlay');
        const scanning = document.getElementById('scanning-ui');
        
        // 1. AudioContextのロック解除
        document.querySelector('a-scene').systems['live-controller'].setupAudio('#bgm');
        
        // 2. オーバーレイを消す
        overlay.style.opacity = 0;
        setTimeout(() => {
            overlay.style.display = 'none';
            scanning.style.display = 'block'; // ガイド枠を表示
        }, 1000);
      };
    </script>
  </head>

  <body>
    <div id="overlay">
      <button id="start-btn" onclick="enterLive()">ENTER LIVE</button>
      <div class="instruction">音量を上げてお待ちください</div>
    </div>

    <div id="scanning-ui"></div>

    <a-scene 
      mindar-image="imageTargetSrc: ./targets.mind; uiScanning: no;" 
      color-space="sRGB" 
      renderer="colorManagement: true, physicallyCorrectLights" 
      vr-mode-ui="enabled: false" 
      device-orientation-permission-ui="enabled: false">
      
      <a-assets>
        <a-asset-item id="model" src="./scene.gltf"></a-asset-item>
        <audio id="bgm" src="./music.m4a" preload="auto" loop></audio>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity mindar-image-target="targetIndex: 0" target-control>
        
        <a-gltf-model 
          class="live-model" 
          src="#model" 
          rotation="90 0 0" 
          position="0 0 0" 
          scale="0 0 0" 
          visible="false">
        </a-gltf-model>

        <a-entity 
          class="live-effects" 
          reactive-mesh 
          visible="false">
        </a-entity>

      </a-entity>
    </a-scene>
  </body>
</html>